from frontend.config.properties import ENDPOINT_UPLOAD, ENDPOINT_RAG
import requests
import json
import os

def upload_support_single_image(className, classes_json, index, filepath):
    """
    Upload a single support image to the backend RAG-Vision API.

    This function mirrors the `/support/upload/image` backend endpoint and is used
    by the frontend to build or update the support dataset class-by-class.
    It also includes verbose debug output to help trace upload issues.

    Args:
        className (str):
            Name of the class that this image belongs to.

        classes_json (str):
            JSON-encoded list of all classes. Must match the expected backend format.

        index (int):
            Sequential index for this uploaded image. If index == 0, the backend
            will reset the entire support directory structure.

        filepath (str):
            Path to the image file that will be uploaded.

    Returns:
        tuple(bool, str or None):
            - success (bool): True if upload succeeded, False otherwise.
            - error_message (str or None): Description of the failure, or None on success.

    Notes:
        - This function performs extensive local-side debugging logs to help diagnose
          file access, network issues, and backend error messages.
    """
    url = ENDPOINT_UPLOAD
    file_exists = os.path.exists(filepath) if isinstance(filepath, str) else False
    try:
        with open(filepath, "rb") as f:
            file_bytes = f.read()

    except Exception as e:

        return False, f"Error reading file '{filepath}': {e}"

    files = {
        "file": ("upload.jpg", file_bytes, "image/jpeg")
    }

    data = {
        "className": className,
        "classes": classes_json,
        "index": str(index),
    }

    try:
        r = requests.post(url, data=data, files=files)
    except Exception as e:

        return False, f"Network error: {e}"

    if r.status_code != 200:
        return False, f"{r.status_code}: {r.text}"

    try:
        resp = r.json()
    except Exception as e:

        return False, "Invalid JSON returned by backend"


    if not resp.get("success", False):
        return False, resp.get("error", "Unknown error")

    return True, None

def run_rag_inference(
    system_prompt, user_prompt,
    encoded_image,
    temperature, top_p,
    k_retrieval, max_patches_per_class,
    max_new_tokens,
    input_resolution,
    support_res,
    support_patch_size
    ):
    """
    Run a full RAG-Vision inference request through the backend API.

    This function sends a JSON payload to `/ragvision/invocations` using the
    inference parameters provided via the frontend UI.

    Args:
        system_prompt (str): System instruction sent to the VLM.
        user_prompt (str): User's natural-language query.
        encoded_image (str): Base64-encoded image for inference.
        temperature (float): Generation temperature for Qwen.
        top_p (float): Nucleus sampling parameter.
        k_retrieval (int): Number of nearest-neighbor patches to retrieve.
        max_patches_per_class (int): Max retrieval patches added per class.
        max_new_tokens (int): Maximum tokens generated by Qwen.
        input_resolution (int): Size to which the input image is resized.
        support_res (int): Resolution used for the support dataset.
        support_patch_size (int): Patch size for CLIP retrieval.

    Returns:
        dict:
            Backend JSON response. Contains:
                - success flag
                - classification flag
                - explanation
                - class_scores
                - raw_response text
                - or an error description if request failed.

    Notes:
        - Handles network exceptions and returns a consistent error structure.
        - Assumes the backend follows the RagVisionOutput schema.
    """
    payload = {
        "imageId": None,
        "encodedImage": encoded_image,
        "systemPrompt": system_prompt,
        "userPrompt": user_prompt,
        "kRetrieval": k_retrieval,
        "maxPatchesPerClass": max_patches_per_class,
        "maxNewTokens": max_new_tokens,
        "inputResolution": input_resolution,
        "supportRes": support_res,
        "supportPatchSize": support_patch_size,
        "temperature": temperature,
        "topP": top_p,
    }

    try:
        r = requests.post(ENDPOINT_RAG, json=payload)
        return r.json()

    except Exception as e:
        return {"success": False, "error": f"Network error: {e}"}